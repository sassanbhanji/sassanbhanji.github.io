<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Does ChessGPT understand Chess? | Sassan Bhanji </title> <meta name="author" content="Sassan Bhanji"> <meta name="description" content="We used mechanistic interpretability to evaluate ChessGPT's understanding of the game"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?v=a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?v=f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?v=62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?v=591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="stylesheet" href="/assets/css/main.css?v=d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://sassanbhanji.github.io/projects/4_project/"> <script src="/assets/js/theme.js?v=a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?v=5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Sassan</span> Bhanji </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">Experience </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">Projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/interests/">Interests </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Does ChessGPT understand Chess?</h1> <p class="post-description">We used mechanistic interpretability to evaluate ChessGPT's understanding of the game</p> </header> <article> <p>This is a write-up of a mini-project I worked on with Mani Ipchi, Prince Kumar and Yusuf Kungdol as part of the Alignment Research Bootcamp Oxford (ARBOx3), building on prior interpretability work on ChessGPT. Credit to Yusuf for the write-up.</p> <p>Adam Karvonen trained a GPT model to predict the next character in chess games written in PGN notation (e.g. 1.e4 e5 2.Nf3 Nc6…). The model was never explicitly given the rules of chess, yet it learned to play at around 1300 Elo and developed internal representations of the board state, as demonstrated through linear probing experiments.</p> <p>Jon Kutasov and David Steinberg then investigated how ChessGPT represents “check” in an ARENA capstone project. They found something concerning: the model relied heavily on the ‘+’ symbol in PGN notation rather than computing whether the king was under attack from piece positions. When they removed ‘+’ from check positions, almost none of the SAE features that were good “check” predictors activated, and the model had nearly a 40% chance of predicting an illegal move.</p> <p>Our question was: can we fix this through fine-tuning?</p> <h4 id="what-is-chessgpt">What is ChessGPT?</h4> <p>ChessGPT is an 8-layer transformer trained on around 16 million chess games in PGN format. Tokenisation is at the character level, so each token is a single character: letters, numbers, spaces, and special symbols like ‘+’ for check and ‘#’ for checkmate. The model’s objective is next-character prediction.</p> <p>The key issue is that every check in the training data was marked with ‘+’. This creates a strong correlation: the model sees millions of examples where ‘+’ appears and the subsequent legal moves are constrained (you must move the king, block, or capture the attacker). The model could easily learn “if I see ‘+’ nearby, certain moves become illegal” without ever learning to compute checks from piece positions.</p> <p>The prior work suggested this is exactly what happened. Our goal was to remove this shortcut through fine-tuning on data without ‘+’ symbols, forcing the model to learn check detection from the actual board state.</p> <h4 id="does-chessgpt-have-an-understanding-of-checks">Does ChessGPT have an understanding of ‘checks’?</h4> <p>We took a dataset of chess games, stripped all ‘+’ symbols from the PGN strings, and fine-tuned the model on 10,000 of these modified games. We then evaluated both the baseline and fine-tuned models on legal move prediction in check positions, testing with and without the ‘+’ symbol present in the input.</p> <p>The baseline model achieves 99.3% legal move accuracy when the ‘+’ symbol is present in the input. This is expected: the model sees the ‘+’ and knows to constrain its predictions to moves that address the check. But when we remove the ‘+’ from the input, accuracy crashes to 57.6%. Nearly half the moves become illegal. The model genuinely does not know it is in check without that symbol telling it so. This confirms the findings from Kutasov and Steinberg, and gives us a clean baseline to improve upon.</p> <p>After fine-tuning on 10,000 games without ‘+’ symbols, the picture changes substantially. The fine-tuned model achieves 97.9% accuracy with ‘+’ present (a small drop from 99.3%, which makes sense since we trained it without that symbol) and 92.2% accuracy without ‘+’. The gap between the two conditions shrinks from 41.7 percentage points to just 5.7 percentage points. This is an 86% reduction in the performance gap, suggesting the model now has something closer to genuine board understanding rather than relying on a notation shortcut.</p> <p>We also measured behavioural consistency: does the model predict the same move whether or not ‘+’ is present? For the baseline, same-move prediction was only 43.2%, meaning the model’s output was highly dependent on whether it saw the ‘+’ symbol. After fine-tuning, this increased to 63.0%. The model’s predictions are now more stable across both conditions.</p> <p>The interpretation is that training on 16 million games with ‘+’ present hardcoded a circuit that detects ‘+’ in the input and uses that to constrain legal move predictions. Fine-tuning without ‘+’ forced the model to develop an alternative pathway that actually computes checks from piece positions. The model learned to do the thing it was supposed to be doing all along.</p> <h4 id="what-about-check-mate">What about ‘check-mate’?</h4> <p>We ran similar experiments for checkmate detection. In PGN, checkmate is indicated with ‘#’ instead of ‘+’.</p> <p>We took 1,000 checkmate positions and tested whether the model could predict ‘#’ at the end of the move. With both ‘#’ and ‘+’ removed from the input, accuracy was 72.9%. With only ‘#’ removed (keeping ‘+’), accuracy improved to 79.6%.</p> <p>The error distribution is revealing. Of all incorrect predictions, 99.5% were the model predicting ‘+’ instead of ‘#’. Only 0.5% were other characters (typically spaces).</p> <p>This tells us the model understands the king is under attack but cannot reliably distinguish check from checkmate. To detect checks, you only need to verify if any enemy piece attacks the king’s square. Checkmate requires verifying that the king cannot escape to any safe square, no piece can block, and no piece can capture the attacker. The model has partially learned the first computation but struggles with the more complex second one. It knows something significant is happening to the king, but not the severity of the situation.</p> <h4 id="effect-of-injecting-fake-checks">Effect of Injecting fake ‘checks’</h4> <p>We also tested the opposite direction: what happens if we add ‘+’ symbols where they should not be? We injected random ‘+’ characters into game strings at non-check positions and fine-tuned a model on this corrupted data. We then measured legal move accuracy on normal positions. In both conditions tested (keeping real ‘+’ or removing all real ‘+’), legal move accuracy dropped to around 50-51%, regardless of whether fake ‘+’ symbols were present or not.</p> <p>A 50% legal move accuracy is essentially broken. For context, a functioning chess model should approach 100%. Injecting fake ‘+’ symbols and training on this corrupted data completely destroys the model’s ability to play chess. This makes sense: if ‘+’ appears randomly and does not correspond to actual check, the model cannot learn any meaningful relationship between the symbol and the game state. It just learns noise.</p> <p>This is a useful negative result. It confirms that ‘+’ carries real information for the model, and that the model’s reliance on this symbol is deep enough that corrupting it breaks everything. You cannot just add random check symbols and expect the model to figure it out.</p> <h4 id="other-interesting-findings">Other interesting findings</h4> <p>We ran preliminary experiments on capture notation (‘x’ in PGN, e.g. Nxe5). The baseline model shows similar dependency: 99.1% legal move accuracy with ‘x’ present, dropping to 89.6% without (a 9.5pp gap, smaller than the 41.7pp for ‘+’).</p> <p>However, fine-tuning without ‘x’ produced unexpected results. After fine-tuning on 1,000 games without ‘x’, accuracy dropped to around 44% in both conditions. Fine-tuning on 10,000 games gave similar results (around 49% with ‘x’, 45% without). Unlike ‘+’ fine-tuning, which successfully taught check detection, ‘x’ fine-tuning broke the model’s ability to play chess entirely.</p> <p>One interpretation is that ‘x’ is more fundamental to how the model processes move sequences than ‘+’ is. The ‘x’ character changes the structure of the move notation itself (compare Ne5 to Nxe5), whereas ‘+’ is appended at the end. Removing ‘x’ might corrupt the model’s understanding of move syntax in a way that removing ‘+’ does not. Another possibility is that our fine-tuning setup was not appropriate for captures. More investigation is needed here.</p> <h4 id="next-steps">Next steps</h4> <p>The natural next step is mechanistic interpretability. Our results suggest there is a circuit somewhere in the model that detects ‘+’ in the input and uses this to affect output logits. Finding this circuit would let us verify exactly how the model was “cheating” and confirm that the fine-tuned model uses a genuinely different mechanism. Other directions include evaluating the no-‘+’ model on checkmate prediction, investigating pawn captures specifically, and checking whether similar notation dependencies exist in other game-playing language models.</p> <p>The broader takeaway is that superficial features in training data can mask whether a model truly understands the underlying domain. The ‘+’ symbol is a clean example: redundant information that the model latched onto instead of learning the actual concept. This is probably happening in other domains too, and it is worth being careful about when evaluating what models have actually learned.</p> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Sassan Bhanji. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?v=a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?v=85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?v=2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?v=c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?v=c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?v=d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?v=a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?v=2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?v=f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?v=a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?v=6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?v=6f508d74becd347268a7f822bca7309d"></script> </body> </html>